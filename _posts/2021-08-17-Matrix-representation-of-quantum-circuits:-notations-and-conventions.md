---
keywords: fastai
description: A case study by building a tensor network to match qiskit conventions
title: Matrix representation of quantum circuits: notations and conventions
toc: true 
badges: true
comments: true
categories: [qiskit, tensor networks, quantum concepts]
image: images/grovercirc.png
nb_path: _notebooks/2021-08-17-Matrix representation of quantum circuits: notations and conventions.ipynb
layout: notebook
---

<!--
#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: _notebooks/2021-08-17-Matrix representation of quantum circuits: notations and conventions.ipynb
-->

<div class="container" id="notebook-container">
        
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="Intro">Intro<a class="anchor-link" href="#Intro"> </a></h1><p>Normally I use <code>qiskit</code> to experiment with quantum circuits. As any higher level environment it is very convenient for common tasks, but may turn out too inflexible for unusual use cases. A somewhat opposite approach is to use much lower level tools to gain in flexibility at the expense of convenience. I wanted to use Google's <code>tensornetwork</code> package for simulations and training of quantum circuits, but this requires building many things that are for free in <code>qiskit</code> from scratch. It is also necessary to become explicit about conventions for matrix representation of quantum circuits. As long as you stay within a single framework this may not be an issue. I always anticipated though, that a day will come when I need to face my fears order all terms in a tensor product myself. Now it seems I'm past the difficult part and I'm better writing this down in case I would need to do something similar in the future.</p>
<p>OK, so what is the problem? Consider the following simple circuit built in <code>qiskit</code>:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">from</span> <span class="nn">qiskit</span> <span class="kn">import</span> <span class="n">QuantumCircuit</span>
<span class="kn">from</span> <span class="nn">qiskit.quantum_info</span> <span class="kn">import</span> <span class="n">Operator</span><span class="p">,</span> <span class="n">Statevector</span>

<span class="n">qc</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">y</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">output</span><span class="o">=</span><span class="s1">&#39;mpl&#39;</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_png output_subarea output_execute_result">
<img src="data:image/png;base64,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
"
>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>It is not hard or ambiguous to interpret what this circuit does by inspecting the diagram. Say the input state is $q_0=|0\rangle$, $q_1=|1\rangle$. After $Y$ acts on $q_0$ it becomes $q_0\to X |0\rangle=|1\rangle$. Similarly, $q_1$ after $Y$ becomes $q_1\to Y|1\rangle=-i |0\rangle$. Since now $q_0$ is "on" the CNOT gate switches the state of $q_1$ further to $q_0 \to -i|1\rangle$. So the end result is that $q_0=|0\rangle, q_1=|1\rangle$ is transformed to $q_0=|0\rangle, q_1=-i|1\rangle$. Similarly we can work out what the circuit does for other computational basis states which by linearity fully fixes the action of the circuit. Although quite explicit, this is a clumsy description. This is why the matrix notation is usually used. And indeed, we can obtain the matrix corresponding to our quantum circuit quite easily in <code>qiskit</code>:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">from</span> <span class="nn">qiskit.quantum_info</span> <span class="kn">import</span> <span class="n">Operator</span><span class="p">,</span> <span class="n">Statevector</span>

<span class="n">U_qs</span> <span class="o">=</span> <span class="n">Operator</span><span class="p">(</span><span class="n">qc</span><span class="p">)</span><span class="o">.</span><span class="n">data</span>
<span class="n">U_qs</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>array([[0.+0.j, 0.+0.j, 0.+0.j, 0.-1.j],
       [0.+1.j, 0.+0.j, 0.+0.j, 0.+0.j],
       [0.+0.j, 0.+1.j, 0.+0.j, 0.+0.j],
       [0.+0.j, 0.+0.j, 0.-1.j, 0.+0.j]])</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>It is important to realize that a number of conventions must be chosen before such explicit matrix representation can be written down. In the following I will clarify what are the conventions used in <code>qiskit</code> and reproduce the circuit with the <code>tensornetwork</code> library.</p>
<h1 id="Conventions-for-states">Conventions for states<a class="anchor-link" href="#Conventions-for-states"> </a></h1><h2 id="Single-qubit">Single qubit<a class="anchor-link" href="#Single-qubit"> </a></h2><p>First we need to give matrix representations to two basis states of a single qubit. Here I think it is quite uncontroversial to chose
\begin{align}
|0\rangle = \begin{pmatrix}1\\0\end{pmatrix},\qquad |1\rangle = \begin{pmatrix}0\\1\end{pmatrix} \label{kets}
\end{align}</p>
<p>These are the "ket" vectors. Their "bra" counterparts are
\begin{align}
\langle 0| = \begin{pmatrix}1 &amp; 0\end{pmatrix}, \qquad \langle 1| = \begin{pmatrix}0 &amp; 1\end{pmatrix} \label{bras}
\end{align}</p>
<p>With these, the following operators can be computed
\begin{align}
|0\rangle\langle 0| = \begin{pmatrix}1 &amp; 0 \\ 0 &amp; 0\end{pmatrix},\qquad |0\rangle\langle 1| = \begin{pmatrix}0 &amp; 1 \\ 0 &amp; 0\end{pmatrix},\qquad |1\rangle\langle 0| = \begin{pmatrix}0 &amp; 0 \\ 1 &amp; 0\end{pmatrix},\qquad |1\rangle\langle 1| = \begin{pmatrix}0 &amp; 0 \\ 0 &amp; 1\end{pmatrix} \label{ketbras}
\end{align}</p>
<h2 id="Multiple-qubits">Multiple qubits<a class="anchor-link" href="#Multiple-qubits"> </a></h2><p>Where there is more than one qubit things become a bit more interesting and potentially confusing.The combined Hilbert space of two qubits $\mathcal{H}_2$ is a tensor product of single-qubit hilbert spaces $\mathcal{H}_2 = \mathcal{H}_1 \otimes \mathcal{H}_1$ but we need to decide which qubit goes first and which goes second. In <code>qiskit</code> a convention is adopted that additional qubits join from the <em>left</em>, i.e. when we have two qubits as here</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<details class="description">
      <summary class="btn btn-sm" data-open="Hide Code" data-close="Show Code"></summary>
        <p><div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">qc01</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">qc01</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">output</span><span class="o">=</span><span class="s1">&#39;mpl&#39;</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>
</p>
    </details>
<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_png output_subarea output_execute_result">
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGYAAAB7CAYAAACGl/UnAAAAOXRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjQuMiwgaHR0cHM6Ly9tYXRwbG90bGliLm9yZy8rg+JYAAAACXBIWXMAAAsTAAALEwEAmpwYAAAD3ElEQVR4nO3cTyj7cRzH8dfmJ5yUVphFZF/ybSO7rdiJ5qoURdGKJBf3Oe4gBxdHVxfLUW4s/0qOTmphVhJHpV18frfVmt/PNz/b9zW/16N28Bl93/Xc5/vl4OMxxhgIHa/bA8jHFIaUwpBSGFIKQ0phSCkMKYUhpTCkFIaUwpBSGFIKQ0phSCkMKYUhpTCkFIaUwpBSGFIKQ0phSCkMKYUhpTCkFIaUwpBSGFIKQ0phSCkMKYUhpTCkFIaUwpBSGFIKQ4o6zPv7OzY3NxEMBtHY2IjBwUFkMhn09fVhcXHR7fEq6pfbA/xNIpHA/v4+kskkIpEIzs/PMTMzg+fnZ6ytrbk9XmUZUru7uwaAOT4+LlmfnJw0AMzl5aVLk1UH7a0slUohHo8jFouVrPf29qK+vh7hcBgAcHd3h1gsBsuyEAqFcHJy4sa438/tT8ZHHh4eDACzs7NT9t709LQZGhoqfj0+Pm62t7eNMcacnZ0Zv99vCoXCp9cA4MrLKcodk8/nAQBtbW0l629vb8hkMhgeHgYAvLy84PT0FIlEAgAQjUbh9/txdHRU3YErgDKMz+cDANzc3JSsb2xs4PHxEZFIBACQy+XQ2tqKhoaG4vd0d3fj/v7+02sYY1x5OUX5W1lPTw/C4TBSqRRaWlrQ0dGBdDqNg4MDACiG+ckod4zX68Xe3h5s28by8jIWFhbg8/mwsrKCurq64oO/s7MTT09PKBQKxZ+9vb1FV1eXW6N/H8dPIwKzs7MmFAqVrI2NjZU8/Nvb2x09/NnVVJj+/n4zPz9fspbNZs3IyIgJBoPGtu2yv3tqlceY2jhI7vX1Fc3Nzdja2sLq6qrb41RczYT531A+/EVhaCkMKYUhpTCkFIaUwpBSGFIKQ0phSCkMKYUhpTCkFIaUwpBSGFIKQ0phSCkMKYUhpTCkFIaUwpBSGFIKQ0phSCkMKYUhpTCkFIaUwpBSGFLUYXTIDykd8kNIh/yQcnrIz/r6OizLgtfrRTqddmPUiqAMk8/ncX19jampqbL3crkcbNsuHlMSj8dxeHiI0dHRao9ZUZTPmM8O+ZmYmCiuRaPRL13D4/F8fcB/YBz+kzjljnF6yM9PRrljqnHIj9NPrlsod4zTQ35+MsodAwCWZZUdCDc3N4eBgQE0NTW5NFX1UO6YP7m6uiq7jSWTSQQCAVxcXGBpaQmBQADZbNalCb9PzZwlo0N+hEJN3cr+JwpDSmFIKQwphSGlMKQUhpTCkFIYUgpDSmFIKQwphSGlMKQUhpTCkFIYUgpDSmFIKQwphSGlMKQUhpTCkFIYUgpDSmFI/Qbm7Y7HugKDCAAAAABJRU5ErkJggg==
"
>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The state of the system is $|q_1\rangle\otimes |q_0\rangle$ (this is of course only true literally for <a href="https://idnm.github.io/blog/quantum%20concepts/qiskit/2021/07/12/Entanglement.html">non-entangled states</a> ). OK, but how do we translate this into the matrix representation? The states in the tensor product of vector spaces can be represented by the <a href="https://en.wikipedia.org/wiki/Kronecker_product">Kronecker product</a> which is not symmetric with respect to permutation arguments. Best way to explain how Kronecker product works is, as usual, through examples:</p>
\begin{align}
\begin{pmatrix} 1 \\ 0 \end{pmatrix} \otimes \begin{pmatrix} a \\ b \end{pmatrix} = \begin{pmatrix} a \\ b \\ 0 \\ 0 \end{pmatrix},\qquad \begin{pmatrix} 0 \\ 1 \end{pmatrix} \otimes \begin{pmatrix} a \\ b \end{pmatrix} = \begin{pmatrix} 0\\ 0\\ a \\ b \end{pmatrix}
\end{align}<p>Result for generic left vector can be obtained by linearity
\begin{align}
\begin{pmatrix} x \\ y \end{pmatrix} \otimes \begin{pmatrix} a \\ b \end{pmatrix} = x \begin{pmatrix} 1 \\ 0 \end{pmatrix} \otimes \begin{pmatrix} a \\ b\end{pmatrix} +y\begin{pmatrix} 0 \\ 1 \end{pmatrix} \otimes \begin{pmatrix} a \\ b \end{pmatrix} = \begin{pmatrix} x a\\ x b\\ y a \\ y b \end{pmatrix}  = \begin{pmatrix} x \begin{pmatrix} a\\ b\end{pmatrix} \\ y  \begin{pmatrix} a \\  b\end{pmatrix} \end{pmatrix}
\end{align}</p>
<p>The last notation here is a bit informal but it shows what happens. One just substitutes the right vector into all elements of the left vector, multiplied by the corresponding components of the left vector. The Kronecker product is defined in the same way for matrices of arbitrary size, not just for two vectors.</p>
<p>So, now we can compute matrix representations of states in the computation basis of two-qubit system</p>
\begin{align}
|00\rangle = \begin{pmatrix}1\\0 \end{pmatrix} \otimes \begin{pmatrix}1\\0 \end{pmatrix} = \begin{pmatrix}1\\0\\0\\0\end{pmatrix},\quad |01\rangle = \begin{pmatrix}1\\0 \end{pmatrix} \otimes \begin{pmatrix}0\\1 \end{pmatrix} = \begin{pmatrix}0\\1\\0\\0\end{pmatrix} \label{01}\\
|10\rangle = \begin{pmatrix}0\\1\end{pmatrix} \otimes \begin{pmatrix}1\\0 \end{pmatrix} = \begin{pmatrix}0\\0\\1\\0\end{pmatrix},\quad |11\rangle = \begin{pmatrix}0\\1\end{pmatrix} \otimes \begin{pmatrix}0\\1 \end{pmatrix} = \begin{pmatrix}0\\0\\0\\1\end{pmatrix}
\end{align}<p>There is a useful relation between the index of the non-zero element $n$ in the four-dimensional representation and the computational basis bitstring $q_1q_0$, namely $n=2q_1+q_0$. I.e. the bitstring $q_1q_0$ is the binary representation of the index $n$. This extends to arbitrary number of qubits, for example (try to obtain this from the tensor products!)
\begin{align}
|101\rangle = \begin{pmatrix}0\\0\\0\\0\\0\\1\\0\\0 \end{pmatrix} \label{101}
\end{align}</p>
<p>Don't believe me? Let's check that! In <code>qiskit</code> there is a convenient function to construct a vector representation from a bit string which we will take advantage of. First start with a two-qubit example:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">s01</span> <span class="o">=</span> <span class="n">Statevector</span><span class="o">.</span><span class="n">from_label</span><span class="p">(</span><span class="s1">&#39;01&#39;</span><span class="p">)</span>
<span class="n">s01</span><span class="o">.</span><span class="n">data</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>array([0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j])</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Comparing to \eqref{01} we find agreement. Similarly,</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">s101</span> <span class="o">=</span> <span class="n">Statevector</span><span class="o">.</span><span class="n">from_label</span><span class="p">(</span><span class="s1">&#39;101&#39;</span><span class="p">)</span>
<span class="n">s101</span><span class="o">.</span><span class="n">data</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>array([0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j])</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Again, this is in agreement with \eqref{101}. Now with conventions for the ordering of tensor products set we can proceed to operators.</p>
<h1 id="Conventions-for-operators">Conventions for operators<a class="anchor-link" href="#Conventions-for-operators"> </a></h1><p>One can say that convention for states representation and ordering of tensor products is a "vertical" convention. There is also a "horizontal" convention which might be potentially confusing. Consider the following circuit</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<details class="description">
      <summary class="btn btn-sm" data-open="Hide Code" data-close="Show Code"></summary>
        <p><div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">qc123</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">qc123</span><span class="o">.</span><span class="n">rx</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">qc123</span><span class="o">.</span><span class="n">ry</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">qc123</span><span class="o">.</span><span class="n">rz</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">qc123</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">output</span><span class="o">=</span><span class="s1">&#39;mpl&#39;</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>
</p>
    </details>
<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_png output_subarea output_execute_result">
<img src="data:image/png;base64,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
"
>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Here, the operator $R_x$ is appplied first, the operator $R_y$ second and $R_z$ last. So in mathematical notation the circuit corresponds to $R_z R_y R_x$ and <em>not</em> to $R_x R_y R_z$. I think that the circuit notation is actually better. We think and write from left to right, this is also a direction that time flows on paper. When another thing happens, we write it to the right and it would be convenient to apply the corresponding operator to the right also.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="What-result-do-we-expect?">What result do we expect?<a class="anchor-link" href="#What-result-do-we-expect?"> </a></h2><p>With the set up in place we can compute the circuit of interest by hands. For convenience I plot it here once again:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">qc</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">output</span><span class="o">=</span><span class="s1">&#39;mpl&#39;</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_png output_subarea output_execute_result">
<img src="data:image/png;base64,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
"
>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>OK, so what is the unitary matrix corresponding to this circuit. It is 
\begin{align}
U = CNOT_{01} \cdot (Y\otimes X)
\end{align}
Here
\begin{multline}
CNOT_{01} = \mathbb{1}\otimes |0\rangle\langle 0|+X\otimes |1\rangle\langle 1|=\\\begin{pmatrix}1&amp;0\\0&amp;1\end{pmatrix}\otimes \begin{pmatrix}1&amp;0\\0&amp;0\end{pmatrix}+\begin{pmatrix}0&amp;1\\1&amp;0\end{pmatrix}\otimes \begin{pmatrix}0&amp;0\\0&amp;1\end{pmatrix}=\begin{pmatrix}1&amp;0&amp;0&amp;0\\0&amp;0&amp;0&amp;1\\0&amp;0&amp;1&amp;0\\0&amp;1&amp;0&amp;0\end{pmatrix}
\end{multline}
and
\begin{align}
Y\otimes X = \begin{pmatrix} 0&amp; -i\\i&amp;0\end{pmatrix} \otimes \begin{pmatrix} 0&amp; 1\\1&amp;0\end{pmatrix}=\begin{pmatrix}0&amp;0&amp;0&amp;-i\\0&amp;0&amp;-i&amp;0\\0&amp;i&amp;0&amp;0\\i&amp;0&amp;0&amp;0\end{pmatrix}
\end{align}
Multiplying them together gives
\begin{align}
U = \begin{pmatrix}0 &amp; 0 &amp; 0 &amp; -i \\ i&amp;0&amp;0&amp;0 \\ 0 &amp; i &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; -i &amp; 0\end{pmatrix}
\end{align}
Alright, so this is indeed the matrix that <code>qiskit</code> computes:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">U_qs</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>array([[0.+0.j, 0.+0.j, 0.+0.j, 0.-1.j],
       [0.+1.j, 0.+0.j, 0.+0.j, 0.+0.j],
       [0.+0.j, 0.+1.j, 0.+0.j, 0.+0.j],
       [0.+0.j, 0.+0.j, 0.-1.j, 0.+0.j]])</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Now-let-us-reproduce-this-with-tensornetworks">Now let us reproduce this with <code>tensornetworks</code><a class="anchor-link" href="#Now-let-us-reproduce-this-with-tensornetworks"> </a></h2>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>First thing we will need are the matrices defining $X, Y$ and $CNOT$ gates. Let us introduce them.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="n">CNOT</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                 <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
                 <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                 <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Now, to actually construct a tensor network we must promote the matrices to <code>tensonework.node</code>'s.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">import</span> <span class="nn">tensornetwork</span> <span class="k">as</span> <span class="nn">tn</span>

<span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">cnot</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">tn</span><span class="o">.</span><span class="n">Node</span><span class="p">,</span> <span class="p">[</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">CNOT</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)]))</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Note that $CNOT$ is a $4\times4$ matrix, to represent in as a tensor with four legs we needed to reshape it appropriately. Reshaping is an important procedure which might be a bit tricky to ingest at first. Let me illustrate how it works on an example. Introduce two $4\times4$ matrices:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">m1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="n">m2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

</div>
 

